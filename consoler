#!/usr/bin/python
from optparse import OptionParser
import os
import sys
import time
from BaseHTTPServer import HTTPServer
from SimpleHTTPServer import SimpleHTTPRequestHandler
import select
import threading
import signal
import Queue
import socket
import urlparse

parser = OptionParser()
parser.add_option('-p', '--port',  type='int', dest='port',
	default=8000, help='Port to serve on')
parser.add_option('--hide',  action='store_true', dest='hide',
	help='Do not stream incoming data to console, only to browser')
(options, args) = parser.parse_args()

Q = Queue.Queue()
SHUTDOWN_EVENT = threading.Event()
LINES = []
EOF = 0

class MyHandler(SimpleHTTPRequestHandler):
	def log_request(self, *args):
		if options.hide:
			SimpleHTTPRequestHandler.log_request(self, *args)
	def do_GET(self):
		if self.path == '/events':
			self.__serveEvents()
		elif self.path in ('/', '/jquery.min.js'):
			SimpleHTTPRequestHandler.do_GET(self)
	def __serveEvents(self):
		try:
			self.send_response(200)
			self.send_header('Content-type', 'text/event-stream')
			self.send_header('Cache-Control', 'no-cache');
			self.end_headers()
			#path = urlparse.urlparse(self.path)
			#params = urlparse.parse_qs(path.query)
			lastEventId = 0
			if self.headers.get('Last-Event-ID'):
				lastEventId = int(self.headers.get('Last-Event-ID'))
			for i in range(lastEventId, len(LINES) - 1):
				self.__writeLine(i)
			while not SHUTDOWN_EVENT.isSet():
				try:
					line = Q.get(True, 1.0/2)
					if line == EOF:
						self.wfile.write('event: eof\n')
						self.wfile.write('data:\n\n')
						break
					line = line.replace('\n', '').replace('\r', '')
					LINES.append(line)
					lineId = len(LINES) - 1
					if lineId > lastEventId:
						self.__writeLine(lineId)
				except Queue.Empty:
					# Try to write anything to spawn excepton if client closed connection
					# otherwise server will hangs here.
					self.wfile.write(' ')
		except socket.error as e:
			self.__handleSocketError(e)
		finally:
			self.wfile.close()
	def __writeLine(self, lineId):
		line = LINES[lineId]
		self.wfile.write('event: line\n')
		self.wfile.write('id: %d\n' % lineId)
		# ^ char is for lines beginning with space
		self.wfile.write('data: ^%s\n\n' % line)
	def __handleSocketError(self, e):
		if e.errno == 32: # Broken pipe
			pass
		else:
			raise


class HttpServerThread(threading.Thread):
	def __init__(self):
		threading.Thread.__init__(self)
		self.httpd = HTTPServer(('', options.port), MyHandler)
	def run(self):
		print 'Consoler serves HTTP at port', options.port
		self.httpd.serve_forever()
	def shutdown(self):
		SHUTDOWN_EVENT.set()
		self.httpd.shutdown()
hst = HttpServerThread()
hst.start()
# Allow server to start serving before we start.
hst.join(1.0/256)

p = select.poll()
p.register(sys.stdin)
try:
	while True:
		fds = p.poll()
		line = sys.stdin.readline()
		if not options.hide:
			sys.stdout.write(line)
		if not line:
			Q.put(EOF)
		Q.put(line)
except KeyboardInterrupt:
	pass
finally:
	hst.shutdown()
print
